<!DOCTYPE html>
<!-- @noSnoop -->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Handling Unit 18</title>
    <script type='text/javascript' src='/requirejs/config.js'></script>
    <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js?'></script>

    <style>
        /* CSS Variables for easy theming */
        :root {
            --bg-color: linear-gradient(to right, #eef2f3, #f4f4f4);
            --text-color: #333;
            --header-color: #0056b3;
            --card-bg-color: #ffffff;
            --card-shadow: 0 4px 15px rgba(0,0,0,0.15);
            --card-shadow-hover: 0 6px 20px rgba(0,0,0,0.2);
            --point-item-bg: #fff;
            --point-item-shadow: 0 2px 5px rgba(0,0,0,0.1);
            --point-item-border: #007bff;
            --point-name-color: #495057;
            --point-value-color: #28a745;
            --status-color: #666;
            --error-color: #dc3545;
            --override-color: #ff6b35;
            --toggle-bg: #e9e9e9;
            --toggle-fg: #f4f4f4;
            --toggle-icon-color: #2c3e50;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-text: #ffffff;
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --control-bg: #f8f9fa;
            
            /* Gauge specific colors */
            --gauge-bg-arc-color: #e0e0e0;
            --gauge-value-color: #28a745;
            --gauge-label-color: #495057;
        }

        body.dark-mode {
            --bg-color: linear-gradient(to right, #2c3e50, #4ca1af);
            --text-color: #f4f4f4;
            --header-color: #76c7ff;
            --card-bg-color: #2c3e50;
            --card-shadow: 0 4px 15px rgba(0,0,0,0.3);
            --card-shadow-hover: 0 6px 20px rgba(0,0,0,0.4);
            --point-item-bg: #34495e;
            --point-item-shadow: 0 2px 5px rgba(0,0,0,0.2);
            --point-item-border: #4ca1af;
            --point-name-color: #bdc3c7;
            --point-value-color: #2ecc71;
            --status-color: #bdc3c7;
            --override-color: #ff8c42;
            --toggle-bg: #76c7ff;
            --toggle-fg: #2c3e50;
            --toggle-icon-color: #f4f4f4;
            --button-bg: #4ca1af;
            --button-hover-bg: #358c99;
            --button-text: #ffffff;
            --input-bg: #34495e;
            --input-border: #4a5568;
            --control-bg: #2c3e50;
            
            /* Dark mode gauge colors */
            --gauge-bg-arc-color: #4a5568;
            --gauge-value-color: #2ecc71;
            --gauge-label-color: #bdc3c7;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background 0.3s ease, color 0.3s ease;
        }

        h1, h2 {
            color: var(--header-color);
            text-align: center;
        }

        /* Theme Toggle Switch Styles */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 20px;
        }
        .theme-switch {
            display: inline-block;
            height: 34px;
            position: relative;
            width: 60px;
        }
        .theme-switch input {
            display:none;
        }
        .slider {
            background-color: var(--toggle-bg);
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            background-color: var(--toggle-fg);
            bottom: 4px;
            content: "";
            height: 26px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 26px;
            border-radius: 50%;
            /* Sun and Moon Icons */
            content: '‚òÄÔ∏è';
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--toggle-icon-color);
        }
        input:checked + .slider {
            background-color: var(--toggle-bg);
        }
        input:checked + .slider:before {
            transform: translateX(26px);
            content: 'üåô';
        }

        #ahu-graphic-svg {
            width: 100%;
            max-width: 900px;
            display: block;
            margin: 20px auto;
            background-color: var(--card-bg-color);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 15px;
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
        }
        
        #ahu-graphic-svg:hover {
            transform: translateY(-2px);
            box-shadow: var(--card-shadow-hover);
        }

        /* Embedded Gauge Containers within SVG */
        .embedded-gauge-container {
            background-color: transparent;
            text-align: center;
            width: 100%;
            height: 100%;
        }

        /* Gauge label styling */
        .gauge-label-text {
            fill: var(--gauge-label-color);
            font-size: 14px;
            font-weight: bold;
        }

        /* Gauge foreground arc styling */
        .gauge-foreground {
            fill: var(--gauge-value-color);
        }

        .point-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .point-item {
            background-color: var(--point-item-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--point-item-shadow);
            border-left: 5px solid var(--point-item-border);
            min-height: 160px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            position: relative;
        }

        /* Override status indicator */
        .point-item.overridden {
            border-left-color: var(--override-color);
        }
        .point-item.overridden::before {
            content: "üîí OVERRIDDEN";
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: var(--override-color);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            font-weight: bold;
        }

        .point-item h3 {
            margin: 0 0 8px 0;
            color: var(--point-name-color);
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .point-value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--point-value-color);
            margin: 8px 0 12px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Special styling for space temp item */
        .point-item.space-temp {
            min-height: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .point-item.space-temp:hover {
            transform: translateY(-2px);
            box-shadow: var(--card-shadow-hover);
        }
        .mini-chart {
            height: 80px;
            margin-top: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .dark-mode .mini-chart {
            background: rgba(255,255,255,0.1);
        }
        .chart-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--status-color);
            font-size: 0.8em;
        }

        /* Control Panel Styles */
        .control-panel {
            background-color: var(--control-bg);
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            border: 1px solid var(--input-border);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-input {
            padding: 6px 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.85em;
            width: 80px;
            box-sizing: border-box;
        }

        .control-select {
            padding: 6px 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.85em;
            min-width: 100px;
            box-sizing: border-box;
        }

        .control-button {
            padding: 6px 12px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }

        .control-button:hover {
            background-color: var(--button-hover-bg);
        }

        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .override-button {
            background-color: #28a745;
        }

        .override-button:hover {
            background-color: #218838;
        }

        .release-button {
            background-color: #dc3545;
        }

        .release-button:hover {
            background-color: #c82333;
        }

        .set-button {
            background-color: #17a2b8;
        }

        .set-button:hover {
            background-color: #138496;
        }

        .control-label {
            font-size: 0.8em;
            color: var(--point-name-color);
            min-width: 60px;
            font-weight: 500;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .status-message {
            margin-top: 20px;
            font-style: italic;
            color: var(--status-color);
            font-size: 0.9em;
            text-align: center;
        }
        .status-message.error {
            color: var(--error-color);
        }

        .controls-section {
            margin-top: 30px;
        }

        /* Popup Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: var(--card-bg-color);
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 1000px;
            height: 80%;
            position: relative;
        }
        .close {
            color: var(--text-color);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .close:hover {
            opacity: 0.7;
        }
        #chart-modal iframe {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="theme-switch-wrapper">
        <label class="theme-switch" for="checkbox">
            <input type="checkbox" id="checkbox" />
            <div class="slider round"></div>
        </label>
    </div>

    <h1>Air Handling Unit 18</h1>

    <!-- Enhanced AHU Graphic based on XML layout -->
    <svg id="ahu-graphic-svg" viewBox="0 0 900 420" preserveAspectRatio="xMidYMid meet">
        <!-- Background -->
        <rect width="900" height="420" fill="transparent"/>
        
        <!-- Outside Air Duct (Left) -->
        <image x="40" y="220" width="120" height="90" href="/file/ahu/Ductwork/Duct_Horz_End_Left.svg" alt="Outside Air Duct"/>
        
        <!-- Damper (2-Way) -->
        <image id="img-damper" x="160" y="100" width="200" height="210" href="/file/ahu/Dampers/Damper_2Way/Damper_2Way_0.svg" alt="Outside Air Damper"/>
        
        <!-- Supply Air Duct (Vertical) -->
        <image x="260" y="0" width="100" height="100" href="/file/ahu/Ductwork/Duct_Vert_End_Up.svg" alt="Supply Air"/>
        
        <!-- T-Junction -->
        <image x="240" y="170" width="150" height="140" href="/file/ahu/Ductwork/Duct_Connector_T_Up.svg" alt="Duct T-Junction"/>
        
        <!-- Main Horizontal Duct -->
        <image x="390" y="220" width="340" height="90" href="/file/ahu/Ductwork/Duct_Horz_Med.svg" alt="Main Duct"/>
        
        <!-- Supply Fan -->
        <image id="img-fan" x="390" y="220" width="130" height="90" href="/file/ahu/Fans/Fans_Horz/Fans_Horz_Right/Fans_Horz_Right_Off.svg" alt="Supply Fan"/>
        
        <!-- DX Cooling Coil -->
        <image id="img-dx-cool" x="530" y="220" width="80" height="90" href="/file/ahu/Coils/Coils_Cooling_DX_1Stg/Coils_Cooling_DX_1Stg_Off.svg" alt="DX Cooling Coil"/>
        
        <!-- Electric Heating Coil -->
        <image id="img-elec-heat" x="630" y="220" width="80" height="90" href="/file/ahu/Coils/Coils_Heating_Electric/Coils_Heating_Electric_Off.svg" alt="Electric Heating Coil"/>
        
        <!-- Discharge Duct (Right) -->
        <image x="730" y="220" width="130" height="90" href="/file/ahu/Ductwork/Duct_Horz_End_Right.svg" alt="Discharge Duct"/>
        
        <!-- Embedded Gauge Containers -->
        <foreignObject x="380" y="20" width="200" height="180">
            <div xmlns="http://www.w3.org/1999/xhtml" class="embedded-gauge-container">
                <div id="gauge-temp-container"></div>
            </div>
        </foreignObject>
        
        <foreignObject x="620" y="20" width="200" height="180">
            <div xmlns="http://www.w3.org/1999/xhtml" class="embedded-gauge-container">
                <div id="gauge-damper-container"></div>
            </div>
        </foreignObject>
    </svg>

    <div class="controls-section">
        <h2>AHU Points & Controls</h2>
        <div id="pointsDisplayContainer" class="point-container"></div>
        <p id="overallStatusMessage" class="status-message">Initializing...</p>
    </div>

    <!-- Chart Modal -->
    <div id="chart-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <iframe src="/file/htmlFiles/chart_lastHour_responsive_plotlyjs_ld.html"></iframe>
        </div>
    </div>

    <script>
        // Theme Toggle Script
        (function() {
            const toggle = document.getElementById('checkbox');
            const currentTheme = localStorage.getItem('theme');

            if (currentTheme) {
                document.body.classList.add(currentTheme);
                if (currentTheme === 'dark-mode') {
                    toggle.checked = true;
                }
            }

            toggle.addEventListener('change', function() {
                if(this.checked) {
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('theme', 'light-mode');
                }
            });
        })();
    </script>
    
    <script>
        require(['baja!', 'baja!control:NumericOverride,control:EnumOverride,control:Override,control:ControlPoint', 'd3'], function (baja, types, d3) {
            'use strict';
            
            // D3.js Gauge Creation Function (UPDATED FOR D3 v7+)
            function createGauge(containerId, label, min, max) {
                var width = 200, height = 180, radius = 80, arcWidth = 25;

                var svg = d3.select(containerId)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", "translate(" + width / 2 + "," + (height / 2 + 30) + ")");

                var labelText = svg.append("text")
                    .attr("class", "gauge-label-text")
                    .attr("text-anchor", "middle")
                    .attr("y", 30)
                    .text(label);

                // UPDATED: Use d3.scaleLinear() instead of d3.scale.linear()
                var scale = d3.scaleLinear().domain([min, max]).range([-Math.PI / 2, Math.PI / 2]).clamp(true);
                
                // UPDATED: Use d3.arc() instead of d3.svg.arc()
                var arc = d3.arc().innerRadius(radius - arcWidth).outerRadius(radius).startAngle(-Math.PI / 2);

                var background = svg.append("path").datum({endAngle: Math.PI / 2}).attr("d", arc);
                var foreground = svg.append("path").datum({endAngle: -Math.PI / 2}).attr("class", "gauge-foreground").attr("d", arc);
                var valueText = svg.append("text").attr("text-anchor", "middle").attr("dy", "0.3em").style("font-size", "30px").style("font-weight", "bold").text("...");

                function updateTheme() {
                    var styles = getComputedStyle(document.documentElement);
                    var bgColor = styles.getPropertyValue('--gauge-bg-arc-color');
                    var valColor = styles.getPropertyValue('--gauge-value-color');

                    background.style("fill", bgColor);
                    valueText.style("fill", valColor);
                }

                function update(valueDisplay) {
                    var numericValue = parseFloat(valueDisplay);
                    if (isNaN(numericValue)) { return; }
                    valueText.text(valueDisplay);
                    foreground.transition().duration(750)
                        .attrTween("d", function(d) {
                            var interpolate = d3.interpolate(d.endAngle, scale(numericValue));
                            return function(t) { d.endAngle = interpolate(t); return arc(d); };
                        });
                }
                
                updateTheme();
                return { update: update, updateTheme: updateTheme };
            }

            // Initialize gauges and points
            const gauges = [];
            const pointsToMonitor = [
                { id: 'Space Temp', ord: 'station:|slot:/AHU/SpaceTemp', name: 'Space Temp', type: 'display' },
                { id: 'Damper Command', ord: 'station:|slot:/AHU/Damper', name: 'Damper Command', type: 'numeric-override' },
                { id: 'Fan Command', ord: 'station:|slot:/AHU/Fan', name: 'Fan Command', type: 'boolean-command' },
                { id: 'Dx Cool', ord: 'station:|slot:/AHU/DX_Cool', name: 'DX Cooling Command', type: 'boolean-command' },
                { id: 'Electric Heat', ord: 'station:|slot:/AHU/Elec_Heat', name: 'Electric Heat Command', type: 'boolean-command' },
                { id: 'Occupancy Command', ord: 'station:|slot:/AHU/Occupancy_Input', name: 'Occupancy', type: 'enum-override' },
                { id: 'Occ Cool Sp', ord: 'station:|slot:/AHU/OccCoolSetpt', name: 'Occupied Cool Setpoint', type: 'setpoint' },
                { id: 'Unocc Cool Sp', ord: 'station:|slot:/AHU/UnoccCoolSetpt', name: 'Unoccupied Cool Setpoint', type: 'setpoint' },
                { id: 'Occ Heat Sp', ord: 'station:|slot:/AHU/OccHeatSetpt', name: 'Occupied Heat Setpoint', type: 'setpoint' },
                { id: 'Unocc Heat Sp', ord: 'station:|slot:/AHU/UnoccHeatSetpt', name: 'Unoccupied Heat Setpoint', type: 'setpoint' }
            ];

            // Create gauges for specific points
            const gaugeConfigs = [
                {
                    id: 'Space Temp',
                    gauge: createGauge('#gauge-temp-container', 'Space Temp (¬∞F)', 60, 80)
                },
                {
                    id: 'Damper Command',
                    gauge: createGauge('#gauge-damper-container', 'Damper Position (%)', 0, 100)
                }
            ];

            gaugeConfigs.forEach(config => gauges.push(config.gauge));

            const subscriber = new baja.Subscriber();
            const pointElementMap = new Map();
            const pointToGaugeMap = new Map();
            const pointObjects = new Map();
            const overrideStatus = new Map();

            // Enhanced graphic update functions
            function updateDamperGraphic(pointValue) {
                const damperImg = document.getElementById('img-damper');
                let imageName;
                if (pointValue >= 80.0) imageName = 'Damper_2Way_4.svg';
                else if (pointValue >= 60.0) imageName = 'Damper_2Way_3.svg';
                else if (pointValue >= 40.0) imageName = 'Damper_2Way_2.svg';
                else if (pointValue >= 20.0) imageName = 'Damper_2Way_1.svg';
                else imageName = 'Damper_2Way_0.svg';
                damperImg.setAttribute('href', '/file/ahu/Dampers/Damper_2Way/' + imageName);
            }

            function updateFanGraphic(isOn) {
                const fanImg = document.getElementById('img-fan');
                const imageName = isOn ? 'Fans_Horz_Right_On.svg' : 'Fans_Horz_Right_Off.svg';
                fanImg.setAttribute('href', '/file/ahu/Fans/Fans_Horz/Fans_Horz_Right/' + imageName);
            }

            function updateDXCoolGraphic(isOn) {
                const coolImg = document.getElementById('img-dx-cool');
                const imageName = isOn ? 'Coils_Cooling_DX_1Stg_On.svg' : 'Coils_Cooling_DX_1Stg_Off.svg';
                coolImg.setAttribute('href', '/file/ahu/Coils/Coils_Cooling_DX_1Stg/' + imageName);
            }

            function updateElecHeatGraphic(isOn) {
                const heatImg = document.getElementById('img-elec-heat');
                const imageName = isOn ? 'Coils_Heating_Electric_On.svg' : 'Coils_Heating_Electric_Off.svg';
                heatImg.setAttribute('href', '/file/ahu/Coils/Coils_Heating_Electric/' + imageName);
            }
            
            const overallStatusMessageElement = document.getElementById('overallStatusMessage');
            const pointsDisplayContainer = document.getElementById('pointsDisplayContainer');
            
            // Function to check if a point is overridden
            function checkOverrideStatus(point, pointConfig) {
                try {
                    let isOverridden = false;
                    
                    if (point && typeof point.getStatus === 'function') {
                        const status = point.getStatus();
                        if (status) {
                            if (typeof status.Overridden !== 'undefined') {
                                isOverridden = status.Overridden;
                            } else if (typeof status.overridden !== 'undefined') {
                                isOverridden = status.overridden;
                            } else {
                                const statusStr = status.toString().toLowerCase();
                                isOverridden = statusStr.includes('overridden') || statusStr.includes('override') || statusStr.includes('manual');
                            }
                        }
                    }
                    
                    const itemElement = document.getElementById(`item-${pointConfig.id}`);
                    if (itemElement) {
                        if (isOverridden) {
                            itemElement.classList.add('overridden');
                        } else {
                            itemElement.classList.remove('overridden');
                        }
                    }
                    
                    overrideStatus.set(pointConfig.id, isOverridden);
                    return isOverridden;
                    
                } catch (e) {
                    console.error('Override status check failed for', pointConfig.name, ':', e);
                    return false;
                }
            }
            
            function updatePoint(point, pointConfig) {
                const valueElement = document.getElementById(`value-${pointConfig.id}`);
                if (!valueElement) return;
                try {
                    if (point && typeof point.getOut === 'function') {
                        const out = point.getOut();
                        const numericValue = out.getValue();
                        const booleanValue = numericValue > 0;
                        
                        valueElement.textContent = out.getValueDisplay();
                        
                        checkOverrideStatus(point, pointConfig);
                        
                        switch(pointConfig.id) {
                            case 'Damper Command':
                                updateDamperGraphic(numericValue);
                                break;
                            case 'Fan Command':
                                updateFanGraphic(booleanValue);
                                break;
                            case 'Dx Cool':
                                updateDXCoolGraphic(booleanValue);
                                break;
                            case 'Electric Heat':
                                updateElecHeatGraphic(booleanValue);
                                break;
                        }
                    }
                } catch (e) {
                    console.error('Error updating point:', pointConfig.name, e);
                }
            }

            // Control Functions remain the same as they don't use D3
            function getDurationInSeconds(pointId) {
                const durationSelect = document.getElementById(`duration-${pointId}`);
                const customInput = document.getElementById(`custom-duration-${pointId}`);
                
                if (!durationSelect) return null;
                
                const selectedValue = durationSelect.value;
                if (selectedValue === 'permanent') {
                    return null;
                } else if (selectedValue === 'custom') {
                    const customMinutes = parseFloat(customInput.value);
                    if (isNaN(customMinutes) || customMinutes <= 0) {
                        throw new Error('Please enter a valid custom duration in minutes');
                    }
                    return customMinutes * 60;
                } else {
                    return parseInt(selectedValue);
                }
            }

            function performOverride(pointId, value, customDuration = null) {
                const point = pointObjects.get(pointId);
                if (!point) return Promise.reject('Point not found');

                const pointConfig = pointsToMonitor.find(p => p.id === pointId);
                
                try {
                    let overrideValue;
                    const duration = customDuration !== null ? customDuration : getDurationInSeconds(pointId);
                    
                    if (pointConfig.type === 'numeric-override') {
                        const overrideConfig = {
                            value: parseFloat(value)
                        };
                        
                        if (duration !== null) {
                            overrideConfig.duration = baja.RelTime.make({ seconds: duration });
                        }
                        
                        overrideValue = baja.$("control:NumericOverride", overrideConfig);
                    } else if (pointConfig.type === 'enum-override') {
                        try {
                            console.log('=== ENUM OVERRIDE DEBUG START ===');
                            console.log('Creating enum override with value:', value);
                            console.log('Point ID:', pointId);
                            console.log('Point Config:', pointConfig);
                            
                            let selectedOrdinal = null;
                            let enumRange = null;
                            
                            // Step 1: Try to get the enum range from multiple sources
                            try {
                                const enumOut = point.getOut();
                                const currentEnumValue = enumOut.getValue();
                                console.log('Current enum out:', enumOut);
                                console.log('Current enum value:', currentEnumValue);
                                console.log('Current enum value type:', typeof currentEnumValue);
                                
                                // Method 1: Get range from current enum value
                                if (currentEnumValue && typeof currentEnumValue.getRange === 'function') {
                                    enumRange = currentEnumValue.getRange();
                                    console.log('Got range from current enum value:', enumRange);
                                }
                                
                                // Method 2: Get range from point facets
                                if (!enumRange) {
                                    const pointFacets = point.getFacets();
                                    console.log('Point facets:', pointFacets);
                                    if (pointFacets && pointFacets.has('range')) {
                                        enumRange = pointFacets.get('range');
                                        console.log('Got range from point facets:', enumRange);
                                    }
                                }
                                
                                // Method 3: Get range from out type
                                if (!enumRange) {
                                    const outType = enumOut.getType();
                                    console.log('Out type:', outType);
                                    if (outType && typeof outType.getRange === 'function') {
                                        enumRange = outType.getRange();
                                        console.log('Got range from out type:', enumRange);
                                    }
                                }
                                
                            } catch (e) {
                                console.error('Error getting enum context:', e);
                            }
                            
                            // Step 2: Parse the range to find ordinal mapping
                            if (enumRange) {
                                const rangeString = enumRange.toString();
                                console.log('Range string:', rangeString);
                                
                                // Parse pattern like {Occupied=1,UnOccupied=2,Standby=3,Override=4}
                                const match = rangeString.match(/\{([^}]+)\}/);
                                if (match) {
                                    const enumPairs = match[1].split(',');
                                    const ordinalMap = {};
                                    const caseInsensitiveMap = {};
                                    enumPairs.forEach(pair => {
                                        const [name, ordinal] = pair.split('=');
                                        if (name && ordinal) {
                                            const trimmedName = name.trim();
                                            const ordinalNum = parseInt(ordinal.trim());
                                            ordinalMap[trimmedName] = ordinalNum;
                                            // Create case-insensitive lookup
                                            caseInsensitiveMap[trimmedName.toLowerCase()] = {
                                                actualName: trimmedName,
                                                ordinal: ordinalNum
                                            };
                                        }
                                    });
                                    
                                    console.log('Ordinal map:', ordinalMap);
                                    console.log('Case-insensitive map:', caseInsensitiveMap);
                                    
                                    // Try exact match first
                                    selectedOrdinal = ordinalMap[value];
                                    
                                    // If no exact match, try case-insensitive
                                    if (selectedOrdinal === undefined) {
                                        const lowerValue = value.toLowerCase();
                                        const caseMatch = caseInsensitiveMap[lowerValue];
                                        if (caseMatch) {
                                            selectedOrdinal = caseMatch.ordinal;
                                            console.log('Found case-insensitive match:', lowerValue, '->', caseMatch.actualName, '=', selectedOrdinal);
                                        }
                                    }
                                    
                                    console.log('Selected ordinal for', value, ':', selectedOrdinal);
                                } else {
                                    console.warn('Could not parse range string pattern');
                                }
                            } else {
                                console.warn('No enum range found - using fallback ordinals');
                                // Fallback hardcoded mapping for occupancy
                                const fallbackMap = {
                                    'Occupied': 1,
                                    'UnOccupied': 2,
                                    'Unoccupied': 2,  // Handle both cases
                                    'Standby': 3,
                                    'Override': 4
                                };
                                selectedOrdinal = fallbackMap[value];
                                console.log('Using fallback ordinal:', selectedOrdinal);
                            }
                            
                            if (selectedOrdinal === undefined || selectedOrdinal === null) {
                                throw new Error('Could not find ordinal for enum value: ' + value + '. Available range: ' + (enumRange ? enumRange.toString() : 'none'));
                            }
                            
                            // Step 3: Create DynamicEnum - try multiple approaches
                            let dynamicEnumValue;
                            
                            try {
                                // Method 1: Try with range context (new approach for 4.15.1)
                                if (enumRange) {
                                    console.log('Attempting to create DynamicEnum with range context...');
                                    dynamicEnumValue = baja.DynamicEnum.make(selectedOrdinal, enumRange);
                                    console.log('Created DynamicEnum with range context:', dynamicEnumValue);
                                } else {
                                    console.log('Attempting to create DynamicEnum without range context...');
                                    dynamicEnumValue = baja.DynamicEnum.make(selectedOrdinal);
                                    console.log('Created DynamicEnum without range context:', dynamicEnumValue);
                                }
                            } catch (enumCreateError) {
                                console.error('First DynamicEnum creation failed:', enumCreateError);
                                
                                // Method 2: Fallback - try without range
                                try {
                                    console.log('Trying fallback DynamicEnum creation...');
                                    dynamicEnumValue = baja.DynamicEnum.make(selectedOrdinal);
                                    console.log('Fallback DynamicEnum created:', dynamicEnumValue);
                                } catch (fallbackError) {
                                    console.error('Fallback DynamicEnum creation also failed:', fallbackError);
                                    throw fallbackError;
                                }
                            }
                            
                            console.log('DynamicEnum toString():', dynamicEnumValue.toString());
                            console.log('DynamicEnum ordinal:', dynamicEnumValue.getOrdinal ? dynamicEnumValue.getOrdinal() : 'no getOrdinal method');
                            
                            // Step 4: Create EnumOverride
                            const enumOverride = baja.$("control:EnumOverride");
                            enumOverride.setValue(dynamicEnumValue);
                            
                            if (duration !== null) {
                                enumOverride.setDuration(baja.RelTime.make({ seconds: duration }));
                                console.log('Set duration to', duration, 'seconds');
                            }
                            
                            overrideValue = enumOverride;
                            console.log('Created EnumOverride successfully:', overrideValue);
                            console.log('EnumOverride value:', overrideValue.getValue());
                            console.log('EnumOverride value toString():', overrideValue.getValue().toString());
                            console.log('=== ENUM OVERRIDE DEBUG END ===');
                            
                        } catch (enumError) {
                            console.error('=== ENUM OVERRIDE ERROR ===');
                            console.error('Error creating enum override:', enumError);
                            console.error('Stack trace:', enumError.stack);
                            console.error('=== END ERROR ===');
                            return Promise.reject('Failed to create enum override: ' + enumError.message);
                        }
                    } else {
                        return Promise.reject('Unsupported point type for override: ' + pointConfig.type);
                    }

                    return point.invoke({
                        slot: 'override',
                        value: overrideValue
                    });
                } catch (error) {
                    return Promise.reject(error);
                }
            }

            function releaseOverride(pointId) {
                const point = pointObjects.get(pointId);
                if (!point) return Promise.reject('Point not found');
                return point.invoke({ slot: 'auto' });
            }

            function setSetpoint(pointId, value) {
                const point = pointObjects.get(pointId);
                if (!point) return Promise.reject('Point not found');
                return point.getFallback().setValue(parseFloat(value));
            }

            function loadEnumFacets(point, pointConfig) {
                try {
                    const inputSelect = document.getElementById(`input-${pointConfig.id}`);
                    if (!inputSelect || pointConfig.type !== 'enum-override') return;

                    const out = point.getOut();
                    const enumType = out.getType();
                    
                    let optionsAdded = false;
                    
                    console.log('Enum type for', pointConfig.name, ':', enumType);
                    
                    try {
                        const pointFacets = point.getFacets();
                        if (pointFacets && pointFacets.has('range')) {
                            const enumRange = pointFacets.get('range');
                            console.log('Found enum range in point facets:', enumRange);
                            
                            const rangeString = enumRange.toString();
                            const match = rangeString.match(/\{([^}]+)\}/);
                            if (match) {
                                const enumPairs = match[1].split(',');
                                const enumNames = enumPairs.map(pair => pair.split('=')[0].trim());
                                
                                if (enumNames.length > 0) {
                                    enumNames.forEach(name => {
                                        const option = document.createElement('option');
                                        option.value = name;
                                        option.textContent = name;
                                        inputSelect.appendChild(option);
                                    });
                                    optionsAdded = true;
                                    console.log('Loaded enum options from point facets for', pointConfig.name);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Could not get enum range from point facets:', e);
                    }
                    
                    if (!optionsAdded) {
                        try {
                            if (typeof enumType.getRange === 'function') {
                                const enumRange = enumType.getRange();
                                console.log('Found type range:', enumRange);
                                
                                if (enumRange) {
                                    const rangeString = enumRange.toString();
                                    const match = rangeString.match(/\{([^}]+)\}/);
                                    if (match) {
                                        const enumPairs = match[1].split(',');
                                        const enumNames = enumPairs.map(pair => pair.split('=')[0].trim());
                                        
                                        if (enumNames.length > 0) {
                                            enumNames.forEach(name => {
                                                const option = document.createElement('option');
                                                option.value = name;
                                                option.textContent = name;
                                                inputSelect.appendChild(option);
                                            });
                                            optionsAdded = true;
                                            console.log('Loaded enum options from type range for', pointConfig.name);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('Could not get enum range from type:', e);
                        }
                    }
                    
                    if (!optionsAdded) {
                        try {
                            const currentValue = out.getValueDisplay();
                            console.log('Current enum value:', currentValue);
                            
                            if (currentValue.toLowerCase().includes('occup') || pointConfig.name.toLowerCase().includes('occup')) {
                                const occupancyValues = ['Occupied', 'UnOccupied', 'Standby', 'Override'];
                                occupancyValues.forEach(value => {
                                    const option = document.createElement('option');
                                    option.value = value;
                                    option.textContent = value;
                                    inputSelect.appendChild(option);
                                });
                                optionsAdded = true;
                                console.log('Loaded hardcoded occupancy values for', pointConfig.name);
                            }
                        } catch (e) {
                            console.warn('Could not analyze current enum value:', e);
                        }
                    }
                    
                    if (!optionsAdded) {
                        console.warn('Using final fallback enum values for', pointConfig.name);
                        const defaultValues = ['Occupied', 'UnOccupied', 'Standby', 'Override'];
                        defaultValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            inputSelect.appendChild(option);
                        });
                        optionsAdded = true;
                    }
                    
                    console.log('Final dropdown options for', pointConfig.name, ':', 
                        Array.from(inputSelect.options).map(opt => opt.value));
                    
                } catch (error) {
                    console.error('Error loading enum facets for', pointConfig.name, ':', error);
                    const inputSelect = document.getElementById(`input-${pointConfig.id}`);
                    if (inputSelect) {
                        const defaultValues = ['Occupied', 'UnOccupied', 'Standby', 'Override'];
                        defaultValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            inputSelect.appendChild(option);
                        });
                    }
                }
            }

            function createControlPanel(pointConfig) {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'control-panel';

                if (pointConfig.type === 'numeric-override') {
                    controlDiv.innerHTML = `
                        <div class="control-row">
                            <span class="control-label">Override:</span>
                            <input type="number" class="control-input" id="input-${pointConfig.id}" placeholder="Value" step="0.1">
                        </div>
                        <div class="control-row">
                            <span class="control-label">Duration:</span>
                            <select class="control-select" id="duration-${pointConfig.id}">
                                <option value="permanent">Permanent</option>
                                <option value="60">1 minute</option>
                                <option value="900">15 minutes</option>
                                <option value="1800">30 minutes</option>
                                <option value="3600">1 hour</option>
                                <option value="7200">2 hours</option>
                                <option value="10800">3 hours</option>
                                <option value="custom">Custom</option>
                            </select>
                            <input type="number" class="control-input" id="custom-duration-${pointConfig.id}" placeholder="Min" style="display:none;" min="1">
                        </div>
                        <div class="control-row">
                            <button class="control-button override-button" onclick="handleOverride('${pointConfig.id}')">Override</button>
                            <button class="control-button release-button" onclick="handleRelease('${pointConfig.id}')">Release</button>
                        </div>
                    `;
                } else if (pointConfig.type === 'boolean-command') {
                    controlDiv.innerHTML = `
                        <div class="control-row">
                            <span class="control-label">Command:</span>
                            <select class="control-select" id="input-${pointConfig.id}">
                                <option value="auto" selected>Auto</option>
                                <option value="true">Active</option>
                                <option value="false">Inactive</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <span class="control-label">Duration:</span>
                            <select class="control-select" id="duration-${pointConfig.id}">
                                <option value="permanent">Permanent</option>
                                <option value="60">1 minute</option>
                                <option value="900">15 minutes</option>
                                <option value="1800">30 minutes</option>
                                <option value="3600">1 hour</option>
                                <option value="7200">2 hours</option>
                                <option value="10800">3 hours</option>
                                <option value="custom">Custom</option>
                            </select>
                            <input type="number" class="control-input" id="custom-duration-${pointConfig.id}" placeholder="Min" style="display:none;" min="1">
                        </div>
                        <div class="control-row">
                            <button class="control-button override-button" onclick="handleBooleanCommand('${pointConfig.id}')">Override</button>
                            <button class="control-button release-button" onclick="handleBooleanRelease('${pointConfig.id}')">Release</button>
                        </div>
                    `;
                } else if (pointConfig.type === 'enum-override') {
                    controlDiv.innerHTML = `
                        <div class="control-row">
                            <span class="control-label">Override:</span>
                            <select class="control-select" id="input-${pointConfig.id}">
                                <option value="" selected>Select...</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <span class="control-label">Duration:</span>
                            <select class="control-select" id="duration-${pointConfig.id}">
                                <option value="permanent">Permanent</option>
                                <option value="60">1 minute</option>
                                <option value="900">15 minutes</option>
                                <option value="1800">30 minutes</option>
                                <option value="3600">1 hour</option>
                                <option value="7200">2 hours</option>
                                <option value="10800">3 hours</option>
                                <option value="custom">Custom</option>
                            </select>
                            <input type="number" class="control-input" id="custom-duration-${pointConfig.id}" placeholder="Min" style="display:none;" min="1">
                        </div>
                        <div class="control-row">
                            <button class="control-button override-button" onclick="handleOverride('${pointConfig.id}')">Override</button>
                            <button class="control-button release-button" onclick="handleRelease('${pointConfig.id}')">Release</button>
                        </div>
                    `;
                } else if (pointConfig.type === 'setpoint') {
                    controlDiv.innerHTML = `
                        <div class="control-row">
                            <span class="control-label">Set:</span>
                            <input type="number" class="control-input" id="input-${pointConfig.id}" placeholder="Value" step="0.1">
                            <button class="control-button set-button" onclick="handleSetpoint('${pointConfig.id}')">Set</button>
                        </div>
                    `;
                }

                setTimeout(() => {
                    const durationSelect = document.getElementById(`duration-${pointConfig.id}`);
                    const customInput = document.getElementById(`custom-duration-${pointConfig.id}`);
                    if (durationSelect && customInput) {
                        durationSelect.addEventListener('change', function() {
                            if (this.value === 'custom') {
                                customInput.style.display = 'inline-block';
                            } else {
                                customInput.style.display = 'none';
                            }
                        });
                    }
                }, 100);

                return controlDiv;
            }

            function createMiniChart(pointConfig) {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'mini-chart';
                chartDiv.id = 'mini-chart-container';
                
                const sparklineHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; 
                                color: var(--status-color); font-size: 0.8em; text-align: center; position: relative;">
                        <div style="font-size: 1.2em; margin-bottom: 4px;">üìä</div>
                        <div style="font-weight: 500; color: var(--point-value-color);">Temperature History</div>
                        <div style="font-size: 0.7em; margin-top: 2px; opacity: 0.7;">Click for full chart</div>
                        <div style="position: absolute; bottom: 8px; left: 0px; right: 0px; height: 20px;">
                            <svg width="100%" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20" preserveAspectRatio="none" style="opacity: 0.6;">
                                <defs>
                                    <linearGradient id="sparkGradient-${pointConfig.id}" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:var(--gauge-value-color);stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:var(--gauge-value-color);stop-opacity:0.2" />
                                    </linearGradient>
                                </defs>
                                <path d="M0,12 L8,8 L16,14 L24,6 L32,10 L40,4 L48,9 L56,12 L64,7 L72,11 L80,5 L88,13 L96,9 L100,15" 
                                      stroke="var(--gauge-value-color)" 
                                      stroke-width="1.5" 
                                      fill="none" 
                                      opacity="0.8"/>
                                <path d="M0,12 L8,8 L16,14 L24,6 L32,10 L40,4 L48,9 L56,12 L64,7 L72,11 L80,5 L88,13 L96,9 L100,15 L100,20 L0,20 Z" 
                                      fill="url(#sparkGradient-${pointConfig.id})" 
                                      opacity="0.3"/>
                            </svg>
                        </div>
                    </div>
                `;
                
                chartDiv.innerHTML = sparklineHTML;
                return chartDiv;
            }

            function createPointDisplayElements() {
                pointsToMonitor.forEach(pointConfig => {
                    let itemDiv = document.createElement('div');
                    itemDiv.id = `item-${pointConfig.id}`;
                    itemDiv.className = 'point-item';
                    
                    if (pointConfig.id === 'Space Temp') {
                        itemDiv.classList.add('space-temp');
                        itemDiv.addEventListener('click', function() {
                            document.getElementById('chart-modal').style.display = 'block';
                        });
                    }
                    
                    const nameHeader = document.createElement('h3');
                    nameHeader.textContent = pointConfig.name;
                    
                    const valuePara = document.createElement('p');
                    valuePara.id = `value-${pointConfig.id}`;
                    valuePara.className = 'point-value';
                    valuePara.textContent = 'Loading...';
                    
                    itemDiv.appendChild(nameHeader);
                    itemDiv.appendChild(valuePara);
                    
                    // Add mini chart for space temp
                    if (pointConfig.id === 'Space Temp') {
                        const miniChart = createMiniChart(pointConfig);
                        itemDiv.appendChild(miniChart);
                    }
                    
                    if (pointConfig.type !== 'display') {
                        const controlPanel = createControlPanel(pointConfig);
                        itemDiv.appendChild(controlPanel);
                    }
                    
                    pointsDisplayContainer.appendChild(itemDiv);
                });
            }

            // Modal functionality
            const modal = document.getElementById('chart-modal');
            const closeBtn = document.querySelector('.close');
            
            closeBtn.onclick = function() {
                modal.style.display = 'none';
            }
            
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }

            // Global functions for control buttons
            window.handleBooleanCommand = function(pointId) {
                const inputElement = document.getElementById(`input-${pointId}`);
                const value = inputElement.value;
                
                const point = pointObjects.get(pointId);
                if (!point) {
                    alert('Point not found');
                    return;
                }
                
                let actionPromise;
                
                if (value === 'auto') {
                    actionPromise = point.invoke({ slot: 'auto' });
                } else {
                    try {
                        const duration = getDurationInSeconds(pointId);
                        const slotName = value === 'true' ? 'active' : 'inactive';
                        
                        if (duration === null) {
                            const overrideParam = baja.$("control:Override");
                            actionPromise = point.invoke({ 
                                slot: slotName, 
                                value: overrideParam 
                            });
                        } else {
                            const overrideParam = baja.$("control:Override");
                            overrideParam.setDuration(baja.RelTime.make({ seconds: duration }));
                            actionPromise = point.invoke({ 
                                slot: slotName, 
                                value: overrideParam 
                            });
                        }
                    } catch (error) {
                        console.error('Error creating boolean command:', error);
                        alert(`Command error: ${error.message}`);
                        return;
                    }
                }
                
                actionPromise
                    .then(() => {
                        console.log(`${value} command successful for ${pointId}`);
                        inputElement.value = value;
                        
                        setTimeout(() => {
                            const pointConfig = pointsToMonitor.find(p => p.id === pointId);
                            if (pointConfig) {
                                checkOverrideStatus(point, pointConfig);
                            }
                        }, 500);
                    })
                    .catch(error => {
                        console.error(`${value} command failed for ${pointId}:`, error);
                        alert(`Command failed: ${error}`);
                    });
            };

            window.handleBooleanRelease = function(pointId) {
                const point = pointObjects.get(pointId);
                if (!point) {
                    alert('Point not found');
                    return;
                }
                
                point.invoke({ slot: 'auto' })
                    .then(() => {
                        console.log(`Release successful for ${pointId}`);
                        const inputElement = document.getElementById(`input-${pointId}`);
                        if (inputElement) {
                            inputElement.value = 'auto';
                        }
                        
                        setTimeout(() => {
                            const pointConfig = pointsToMonitor.find(p => p.id === pointId);
                            if (pointConfig) {
                                checkOverrideStatus(point, pointConfig);
                            }
                        }, 500);
                    })
                    .catch(error => {
                        console.error(`Release failed for ${pointId}:`, error);
                        alert(`Release failed: ${error}`);
                    });
            };

            window.handleOverride = function(pointId) {
                const inputElement = document.getElementById(`input-${pointId}`);
                const value = inputElement.value;
                
                if (!value && value !== false) {
                    alert('Please enter a value');
                    return;
                }
                
                try {
                    performOverride(pointId, value)
                        .then(() => {
                            console.log(`Override successful for ${pointId}`);
                            
                            const point = pointObjects.get(pointId);
                            setTimeout(() => {
                                const pointConfig = pointsToMonitor.find(p => p.id === pointId);
                                if (pointConfig && point) {
                                    checkOverrideStatus(point, pointConfig);
                                }
                            }, 500);
                        })
                        .catch(error => {
                            console.error(`Override failed for ${pointId}:`, error);
                            alert(`Override failed: ${error}`);
                        });
                } catch (error) {
                    alert(`Override failed: ${error.message}`);
                }
            };

            window.handleRelease = function(pointId) {
                releaseOverride(pointId)
                    .then(() => {
                        console.log(`Release successful for ${pointId}`);
                        const inputElement = document.getElementById(`input-${pointId}`);
                        if (inputElement) {
                            inputElement.value = '';
                            
                            if (inputElement.tagName === 'SELECT') {
                                inputElement.value = '';
                            }
                        }
                        
                        const point = pointObjects.get(pointId);
                        setTimeout(() => {
                            const pointConfig = pointsToMonitor.find(p => p.id === pointId);
                            if (pointConfig && point) {
                                checkOverrideStatus(point, pointConfig);
                            }
                        }, 500);
                    })
                    .catch(error => {
                        console.error(`Release failed for ${pointId}:`, error);
                        alert(`Release failed: ${error}`);
                    });
            };

            window.handleSetpoint = function(pointId) {
                const inputElement = document.getElementById(`input-${pointId}`);
                const value = inputElement.value;
                
                if (!value) {
                    alert('Please enter a value');
                    return;
                }
                
                setSetpoint(pointId, value)
                    .then(() => {
                        console.log(`Setpoint successful for ${pointId}`);
                        inputElement.value = '';
                    })
                    .catch(error => {
                        console.error(`Setpoint failed for ${pointId}:`, error);
                        alert(`Setpoint failed: ${error}`);
                    });
            };
            
            // Subscriber for handling point changes
            subscriber.attach('changed', function(prop) {
                if (prop.getName() === 'out') {
                    const pointInfo = pointElementMap.get(this);
                    if (pointInfo) updatePoint(this, pointInfo);
                    
                    const gaugeUpdater = pointToGaugeMap.get(this);
                    if (gaugeUpdater) {
                        gaugeUpdater.update(this.getOut().getValueDisplay());
                    }
                }
            });
            
            createPointDisplayElements();
            let resolvedCount = 0;
            const totalPoints = pointsToMonitor.length;

            pointsToMonitor.forEach(pointConfig => {
                baja.Ord.make(pointConfig.ord).get({ subscriber: subscriber })
                    .then(point => {
                        resolvedCount++;
                        overallStatusMessageElement.textContent = `Resolved ${resolvedCount} of ${totalPoints} points.`;
                        pointElementMap.set(point, pointConfig);
                        pointObjects.set(pointConfig.id, point);
                        updatePoint(point, pointConfig);
                        
                        if (pointConfig.type === 'enum-override') {
                            loadEnumFacets(point, pointConfig);
                        }
                        
                        const gaugeConfig = gaugeConfigs.find(g => g.id === pointConfig.id);
                        if (gaugeConfig) {
                            pointToGaugeMap.set(point, gaugeConfig.gauge);
                            gaugeConfig.gauge.update(point.getOut().getValueDisplay());
                        }
                    })
                    .catch(error => {
                        console.error('Error resolving point:', pointConfig.name, error);
                        const valueElement = document.getElementById(`value-${pointConfig.id}`);
                        if(valueElement) {
                            valueElement.textContent = `Not Found`;
                            valueElement.style.color = 'var(--error-color)';
                            valueElement.parentElement.style.borderLeftColor = 'var(--error-color)';
                        }
                    });
            });

            // Enhanced theme handling for gauges
            const toggle = document.getElementById('checkbox');
            
            function applyTheme(theme) {
                if (theme === 'dark-mode') {
                    document.body.classList.add('dark-mode');
                    toggle.checked = true;
                } else {
                    document.body.classList.remove('dark-mode');
                    toggle.checked = false;
                }
                gauges.forEach(gauge => gauge.updateTheme());
            }

            toggle.addEventListener('change', function() {
                const theme = this.checked ? 'dark-mode' : 'light-mode';
                localStorage.setItem('theme', theme);
                applyTheme(theme);
            });

            const savedTheme = localStorage.getItem('theme') || 'light-mode';
            applyTheme(savedTheme);

            // Periodic override status check every 10 seconds
            setInterval(() => {
                pointsToMonitor.forEach(pointConfig => {
                    if (pointConfig.type !== 'display') {
                        const point = pointObjects.get(pointConfig.id);
                        if (point) {
                            checkOverrideStatus(point, pointConfig);
                        }
                    }
                });
            }, 10000);

            window.addEventListener('beforeunload', function() {
                if (subscriber) subscriber.unsubscribeAll();
            });
        });
    </script>
</body>
</html>